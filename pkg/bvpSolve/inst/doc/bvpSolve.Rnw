\documentclass[article,nojss]{jss}
\DeclareGraphicsExtensions{.pdf,.eps}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Add-on packages and fonts
\usepackage{amsmath}
\usepackage{xspace}
\usepackage{verbatim}
\usepackage[english]{babel}
%\usepackage{mathptmx}
%\usepackage{helvet}
\usepackage[T1]{fontenc}
\usepackage[latin1]{inputenc}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% User specified LaTeX commands.
\newcommand{\R}{\proglang{R }\xspace}
\newcommand{\bvp}{\pkg{bvpSolve }\xspace}
\newcommand{\ds}{\pkg{deSolve } \xspace}
\newcommand{\rs}{\pkg{rootSolve }\xspace}

\title{ Package \pkg{bvpSolve}, solving boundary value problems in \proglang{R}}

\Plaintitle{Package bvpSolve, solving boundary value problemns in R }

\Keywords{ordinary differential equations, boundary value problems,
  shooting method, mono-implicit Runge-Kutta,
  \proglang{R}}

\Plainkeywords{ordinary differential equations, boundary value problems,
  shooting method, mono-implicit Runge-Kutta, R}


\author{Karline Soetaert\\
  Centre for Estuarine and Marine Ecology\\
  Netherlands Institute of Ecology\\
  The Netherlands
}

\Plainauthor{Karline Soetaert}

\Abstract{This document is about package \bvp \citep{bvpSolve},
  designed for the numerical
  solution of boundary value problems (BVP) for ordinary differential
  equations (ODE) in \R.

  Package \bvp contains:
  \begin{itemize}
    \item function \code{bvpshoot} which implements the shooting method.
      This method makes use of the initial value problem solvers from
      packages \pkg{deSolve} \citep{deSolve} and the root-finding solver
      from package \pkg{rootSolve} \citep{rootSolve}.
    \item function \code{bvptwp}, the mono-implicit Runge-Kutta (MIRK)
      method with deferred corrections, code TWPBVP
      \citep{Cash91}, for solving two-point  boundary value problems
  \end{itemize}

  The \R functions have an interface which is similar to the interface of
  the solvers in package \ds
}

%% The address of (at least) one author should be given
%% in the following format:
\Address{
  Karline Soetaert\\
  Centre for Estuarine and Marine Ecology (CEME)\\
  Netherlands Institute of Ecology (NIOO)\\
  4401 NT Yerseke, Netherlands
  E-mail: \email{k.soetaert@nioo.knaw.nl}\\
  URL: \url{http://www.nioo.knaw.nl/users/ksoetaert}\\
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% R/Sweave specific LaTeX commands.
%% need no \usepackage{Sweave}
%\VignetteIndexEntry{Solving Boundary Value Problems of Ordinary Differential Equations}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Begin of the document
\begin{document}
\SweaveOpts{engine=R,eps=FALSE}
\SweaveOpts{keep.source=TRUE}

<<preliminaries,echo=FALSE,results=hide>>=
library("bvpSolve")
options(prompt = "> ")
options(width=70)
@ 

\maketitle

\section{Introduction}

  \pkg{bvpSolve} numerically solves boundary value problems (BVP) of
  ordinary differential equations (ODE), which for one (second-order) ODE
  can be written as:

  \begin{eqnarray*}
    \frac{d^2y}{dx^2}=f(x,y,\frac{dy}{dx})\\
    a \leq x\leq b \\
    g_1(y) |_a = 0 \\
    g_2(y) |_b = 0
  \end{eqnarray*}
  where \code{y} is the dependent, \code{x} the independent variable,
  function \code{f} is the differential equation, $g_a$ and $g_b$ the
  boundary conditions at the end points a and b.

  In the current implementation, the boundary conditions must be
  defined at the end of the interval over which the ODE is specified (i.e.
  at \code{a} and/or \code{b}).

  \bvp can only solve sets of first-order ODEs.
  Thus, higher-order ODEs need to be rewritten as a set of first-order systems.

  For instance:
  \begin{eqnarray*}
    \frac{d^2y}{dx^2}=f(x,y,\frac{dy}{dx})
  \end{eqnarray*}
  can be rewritten as:
  \begin{eqnarray*}
    \frac{dy}{dx}=z \\
    \frac{dz}{dx}=f(x,y,z)
  \end{eqnarray*}

  Two BVP solvers are included in \bvp:
  \begin{itemize}
    \item \code{bvpshoot}, implementing the shooting method. This method
      combines solutions of initial value problems (IVP) with solutions
      of nonlinear algebraic equations; it makes use of solvers from
      packages \ds and \rs.
    \item \code{bvptwp}, the mono-implicit Runge-Kutta (MIRK)
      method with deferred corrections, based on FORTRAN code TWPBVP
      \citep{Cash91}.
  \end{itemize}

  Whereas the \code{bvptwp} function is much more efficient if
  \emph{analytical} partial derivatives
  of the differential equations and of boundary conditions are given, input
  is much simpler if these are approximated by \emph{finite differences} by the
  solver. Then, the user need not be concerned with supplying functions
  that estimate these analytical partial derivatives.

  Therefore, by default \bvp function \code{bvptwp} numerically
  approximates the jacobians, and requires a simple input of the boundary
  conditions. This makes the definition of the problem very simple; only one
  function, estimating the derivatives needs to be specified.

  However, it is possible to provide analytical functions,
  in order to speed-up the simulations.

  Even more simulation time will be gained if the problem is specified in
  compiled code (\proglang{FORTRAN, C}). In this case, \R is used to trigger
  the solver \code{bvptwp}, and for post-processing (graphics), while
  solving the BVP itself entirely takes place in compiled code.

  In this package vignette it is shown how to formulate and solve BVPs. We
  use well-known test cases as examples.
  \begin{itemize}
    \item We start with a simple example, comprising a second-order ODE (one from
      the test problems of Jeff Cash)
    \item This is followed
      by a more complex example, which consists of 6 first-order ODEs, the
      "swirling flow III" problem. This example is used to demonstrate how to
      continuate a solution, i.e. use the solution for one problem as initial
      guess for solving another, more complex problem.
    \item How to implement more complex initial conditions is then examplified by
      means of problem "musn".
    \item Next, solving for the fourth eigenvalue of
      "Mathieu's equation" illustrates how to solve a BVP
      including an unknown parameter.
    \item The "elastica" problem is used to demonstrate how
      to specify the analytic jacobians, and how to implement
      problems in \proglang{FORTRAN} or \proglang{C}.
    \item Finally, a linear testcase which has a steep boundary layer is implemented in \proglang{FORTRAN},
      and run with several values of a model parameter.
  \end{itemize}
  
  More examples of boundary value problems can be found in the packages
  \url{examples} subdirectory. They include a.o. all problems found in
  \url{http://www.ma.ic.ac.uk/~jcash/BVP_software}.
  The \url{dynload} subdirectory includes models specified in compiled code.
  
  See also document "bvpSolve: a set of 35 test Problems", which can be
  accessed as \code{vignette("bvpTests")} or is available from the package's
  site on CRAN:
  \url{http://cran.r-project.org/package=bvpSolve/}

\clearpage

\section{A simple BVP example}

  Here is a simple BVP ODE (which is problem 7 from the test problems available
  from \url{http://www.ma.ic.ac.uk/~jcash/BVP_software/readme.php} ):

  \begin{eqnarray*}
    \xi y'' + x y' - y &=&  -(1 + \xi \pi ^2) \cos(\pi x) -\pi x \sin(\pi x)\\
    y(-1) &=& -1 \\
    y(1) &=& 1
  \end{eqnarray*}
  The second-order ODE is expanded as two first-order ODEs as:
  \begin{eqnarray*}
    y_1' &=& y_2 \\
    y_2' &=& 1/\xi \cdot (-x y_2 +y_1 -(1 + \xi \pi ^2) \cos(\pi x) -\pi x \sin(\pi x))\\
  \end{eqnarray*}
  with boundary conditions
  \begin{eqnarray*}
    y_1(-1) &=& -1 \\
    y_1(1) &=& 1
  \end{eqnarray*}
  This is implemented as:
<<>>=
fun<- function(x,y,pars)
{
 list(c(y[2],
   1/ks*(-x*y[2]+y[1]-(1+ks*pi*pi)*cos(pi*x)-pi*x*sin(pi*x)))
     )
}
@
  and solved, using the two methods, as:
<<>>=
ks <- 0.1
x  <- seq(-1,1,by=0.01)
print(system.time(
sol1  <- bvpshoot(yini=c(-1,NA),yend=c(1,NA),x=x,func=fun,guess=0)
))

print(system.time(
sol2  <- bvptwp(yini=c(-1,NA),yend=c(1,NA),x=x,func=fun, guess=0)
))
@
  Note how the boundary conditions at the start (\code{yini}) and
  at the end \code{yend} of the integration interval are specified, where
  \code{NA} is used for boundary conditions that are not known.
  
  A reasonable \code{guess} of the unknown initial condition is
  also inputted.

  As is often the case, the shooting method is faster than the other
  method. However, there are particular problems where
  \code{bvpshoot} does not lead to a solution, whereas the MIRK
  method does (see below).

  The plot shows that the two methods give the same solution:
<<label=pr7a,include=FALSE>>=
plot(sol2[,1],sol2[,3],type="l",main="test problem 7, ksi=0.1",
     lwd=2,col="red")
points(sol1[,1],sol1[,3],col="green",pch="x")
legend("topright",c("bvptwp", "bvpshoot"),
        lty=c(1,NA,NA), pch=c(NA,1,3),col=c("red", "green") )
@

\setkeys{Gin}{width=0.4\textwidth}
\begin{figure}
\begin{center}
<<label=pr7a,fig=TRUE,echo=FALSE>>=
<<pr7a>>
@
\end{center}
\caption{Solution of the simple BVP, for ksi=0.1 - see text for \R-code}
\label{fig:ode}
\end{figure}

When the parameter  $\xi$ is decreased, \code{bvpshoot} cannot solve the problem
anymore, due to the presence of a zone of rapid change near x=0.

However, it can still easily be solved with the MIRK method:
<<>>=
ks <-0.0001

print(system.time(
sol2  <- bvptwp(yini=c(-1,NA),yend=c(1,NA),x=seq(-1,1,by=0.01),
           func=fun, guess=0)
))
@
<<label=pr7b,include=FALSE>>=
plot(sol2[,1],sol2[,3],type="l",main="test problem 7, ksi=0.0001",
     lwd=2,col="red")

@

\setkeys{Gin}{width=0.4\textwidth}
\begin{figure}
\begin{center}
<<label=pr7b,fig=TRUE,echo=FALSE>>=
<<pr7b>>
@
\end{center}
\caption{Solution of the simple BVP, for ksi=0.0001 - see text for \R-code.
  Note that this problem cannot be solved with \code{bvpshoot}}
\label{fig:ode2}
\end{figure}
\clearpage

\section{A more complex BVP example}

  Here the test problem referred to as "swirling flow III" is solved
  \citep{Asher95}.
  
  The original problem definition is:
  \begin{eqnarray*}
    g''&=&(g f' - f g')/ \xi \\
    f''''&=&(-ff'''-gg')/ \xi
  \end{eqnarray*}
  on the interval [0,1] and subject to boundary conditions:
  \begin{eqnarray*}
    g(0)=-1, f(0)= 0, f'(0)= 0 \\
    g(1)=1, f(1)= 0, f'(1)= 0 \\
  \end{eqnarray*}

  This is rewritten as a set of 1st order ODEs as follows:
  \begin{eqnarray*}
    y_1' = y_2                       \\
    y_2' = (y_1*y_4 -y_3*y_2)/ \xi   \\
    y_3' = y_4                       \\
    y_4' = y_5                       \\
    y_5' = y_6                       \\
    y_6' = (-y_3 y_6 - y_1 y_2)/ \xi
  \end{eqnarray*}

  Its implementation in R is:
<<>>=
fsub <- function (t,Y,pars)
{ return(list(c(f1 = Y[2],
                f2 = (Y[1]*Y[4] - Y[3]*Y[2])/eps,
	              f3 = Y[4],
              	f4 = Y[5],
              	f5 = Y[6],
	              f6 = (-Y[3]*Y[6] - Y[1]*Y[2])/eps)))
}
eps <- 0.001
x <- seq(0,1,len=100)
@
This model cannot be solved with the shooting method. However, it can be
solved using \code{bvptwp}:
<<>>=
print(system.time(
Soltwp <- bvptwp(x=x,func=fsub,guess= c(2,0,0),
                      yini=c(y1=-1,y2=NA,y3=0,y4=0,y5=NA,y6=NA),
                      yend=c(1,NA,0,0,NA,NA))
))
@
where the reported system time is in seconds

A pairs plot produces a pretty picture.
<<label=swirl,include=FALSE>>=
pairs(Soltwp, main="swirling flow III, eps=0.01", col="blue")
@

\setkeys{Gin}{width=0.6\textwidth}
\begin{figure}
\begin{center}
<<label=swirl,fig=TRUE,echo=FALSE>>=
<<swirl>>
@
\end{center}
\caption{pairs plot of the swirling flow III problem - see text for \R-code.
  Note that this problem cannot be solved with \code{bvpshoot}}
\label{fig:ode3}
\end{figure}

Using the same input as above, the problem cannot be solved with too small values of eps:
<<>>=
eps <- 1e-9
Soltwp2 <- NA
Soltwp2 <- try(bvptwp(x=x,func=fsub,guess= c(2,0,0),
                      yini=c(y1=-1,y2=NA,y3=0,y4=0,y5=NA,y6=NA),
                      yend=c(1,NA,0,0,NA,NA)),
    silent = TRUE)

cat(Soltwp2)

@

\clearpage
\section{Solving a boundary value problem using continuation}
The previous -swirl- problem can be solved for small values of \code{eps}
if the previous solution (\code{Soltwp}) with eps = 0.001,
is used as an initial guess for smaller value of eps, 0.0001:
<<>>=
eps <- 0.0001
xguess <- Soltwp[,1]
yguess <- t(Soltwp[,2:7])

print(system.time(Sol2 <- bvptwp(x=x,func=fsub,guess= c(2,0,0),
  xguess=xguess,yguess=yguess,yini=c(y1=-1,y2=NA,y3=0,y4=0,y5=NA,y6=NA),
  yend=c(1,NA,0,0,NA,NA))))
@

We use the S3 \code{plot} method to plot all dependent variables at once:
These plots are to be compared with the first column of the "pairs" plot
(figure 3).

<<label=swirl2,include=FALSE>>=
plot(Sol2, col="darkred", type="l", lwd=2)
mtext(outer=TRUE, side=3, line=-1.5, cex=1.5,
   "swirling flow III, eps=0.0001")
@
\setkeys{Gin}{width=0.6\textwidth}
\begin{figure}
\begin{center}
<<label=swirl2,fig=TRUE,echo=FALSE>>=
<<swirl2>>
@
\end{center}
\caption{Solution of the swirling flow III problem with small eps,
 using continuation - see text for \R-code.
}
\label{fig:ode3b}
\end{figure}

\clearpage

\section{More complex initial or end conditions}
  Problem \code{musn} was described in \citep{Asher95}.

  The problem is:
  \begin{eqnarray*}
    u'&=&0.5u(w-u)/v\\
    v'&=&-0.5(w-u)  \\
    w'&=&(0.9-1000(w-y)-0.5w(w-u))/z\\
    z'&=&0.5(w-u)\\
    y'&=&-100(y-w)
  \end{eqnarray*}
  on the interval [0,1] and subject to boundary conditions:
  \begin{eqnarray*}
    u(0)=v(0)=w(0)&=&1\\
    z(0)&=&-10\\
    w(1)&=&y(1)
  \end{eqnarray*}

Note the last boundary condition which expresses \code{w} as a function
of \code{y}.

Implementation of the ODE function is simple:
<<>>=
musn <- function(x,Y,pars)
{
  with (as.list(Y),
  {
   du=0.5*u*(w-u)/v
   dv=-0.5*(w-u)
   dw=(0.9-1000*(w-y)-0.5*w*(w-u))/z
   dz=0.5*(w-u)
   dy=-100*(y-w)
   return(list(c(du,dv,dw,dz,dy)))
  })
}
@

This model is solved differently whether \code{bvpshoot} or \code{bvptwp}
is used.

\subsection{solving musn with bvpshoot}
It is simples to solve the musn model with \code{bvpshoot}:

There are 4 boundary values specified at the start of the interval; a value
for \code{y} is lacking (and set to \code{NA}):
<<>>=
init <- c(u=1,v=1,w=1,z=-10,y=NA)
@

The boundary condition at the end of the integration interval (1) specifies
the value of \code{w} as a function of  \code{y}.

Because of that, \code{yend} cannot be simply inputted as a vector.
It is rather implemented as a function that has as input
the values at the end of the integration interval
  (\code{Y}), the values at the start (\code{yini}) and the parameters, and
  that returns the residual function (\code{w-y}):
<<>>=
yend  <- function (Y,yini,pars)  with (as.list(Y), w-y)
@
Note that the specification of the boundaries for \code{bvptwp} would
be rather different.

The solution, using \code{bvpshoot} is obtained by:
  \footnote{Note that there are at least two solutions to this problem,
  the second solution can simply be found by setting \code{guess}
  equal to 0.9.}
<<>>=
print(system.time(
sol   <-bvpshoot(yini= init, x=seq(0,1,by=0.05),func=musn,
           yend=yend,guess=1,atol=1e-10,rtol=0)
))
@
and plotted as:
<<label=musn,include=FALSE>>=
plot(sol,type="l", lwd=2)
mtext(outer=TRUE, side=3, line=-1.5, cex=1.5, "musn")
@

\setkeys{Gin}{width=0.6\textwidth}
\begin{figure}
\begin{center}
<<label=musn,fig=TRUE,echo=FALSE>>=
<<musn>>
@
\end{center}
\caption{Solution of the musn model, using \code{bvpshoot} -
   see text for \R-code.}
\label{fig:musn}
\end{figure}

\subsection{solving musn with bvptwp}
Here the boundary function \code{bound} must be specified:

<<>>=
bound <- function(i,y,pars) {
  with (as.list(y), {
    if (i ==1) return (u-1)
    if (i ==2) return (v-1)
    if (i ==3) return (w-1)
    if (i ==4) return (z+10)
    if (i ==5) return (w-y)
 })
}
@

Moreover, this problem can only be solved easily if good initial
conditions are given:
<<>>=
xguess <- seq(0,1,len=5)
yguess <- matrix(nc=5,(rep(c(1,1,1,-10,0.91),5)))
rownames(yguess) <- c("u","v","w","z","y")
@
Note that the rows of \code{yguess} have been given a name, such
that this name can be used in the derivative and boundary function.

We specify that there are 4 left boundary conditions.
<<>>=
print(system.time(
Sol <- bvptwp(yini= NULL, x=x, func=musn, bound=bound,
              xguess=xguess, yguess=yguess, leftbc = 4,
              guess=1,atol=1e-10)
))
@

\clearpage

\section{a BVP problem including an unknown parameter}
  In the next BVP problem, \citep{shampine}
  a parameter $\lambda$ is to be found such that:
  \[
    \frac{d^2y}{dt^2}+(\lambda-10 \cos(2t))\cdot y=0
  \]
  on [0,$\pi$] with boundary conditions
  $\frac{dy}{dt}(0)=0$ and $\frac{dy}{dt}(\pi)=0$ and $y(0)=1$

  Here all the initial values (at t=0) are prescribed. If $\lambda$ would
  be known the problem would be overdetermined.

  The $2^{nd}$ order differential equation is first rewritten as two
  $1^{st}$-order equations:
  \begin{eqnarray*}
    \frac{dy}{dt}&=& y2\\
    \frac{dy2}{dt}&=& -(\lambda-10 \cos(2t)) \cdot y
  \end{eqnarray*}
  and the function that estimates these derivatives is written (\code{derivs}).
<<>>=
mathieu <- function(x,y,lambda)
    list(c(y[2],
        -(lambda-10*cos(2*x))*y[1]))
@
\subsection{Solving for an unknown parameter using bvpshoot}
This problem is most easily solved using \code{bvpshoot}; an initial guess of 
the extra parameter to be solved is simply passed via argument \code{guess}.
<<>>=
init <- c(1,0)
sol  <- bvpshoot(yini=init,yend=c(NA,0),x=seq(0,pi,by=0.01),
        func=mathieu, guess=NULL, extra=15)
@
and plotted:
<<label=mat,include=FALSE>>=
plot(sol[,1:2])
mtext(outer=TRUE, side=3, line=-1.5, cex=1.5, "mathieu")
@
\setkeys{Gin}{width=0.4\textwidth}
\begin{figure}
\begin{center}
<<label=mat,fig=TRUE,echo=FALSE>>=
<<mat>>
@
\end{center}
\caption{Solution of the BVP ODE problem including an unknown parameter,
  see text for R-code}
\label{fig:mat}
\end{figure}
The  value of \code{lam} can be printed:
<<>>=
attr(sol,"roots")  # root gives the value of "lam" (17.10684)
@
\subsection{Solving for an unknown parameter using bvptwp}
To use \code{bvptwp}, we treat the unknown parameter as an extra 
variable, whose derivative = 0 (it is a parameter, and by definition 
does not change over the integration interval). 

Thus the model definition becomes:
<<>>=
mathieu2 <- function(x,y,p)
    list(c(y[2],
        -(y[3]-10*cos(2*x))*y[1],
        0) )
@
Note the third derivative, and the parameter \code{lambda} from previous
chapter which is now \code{y[3]}.

The initial condition, \code{yini} and final condition, \code{yend} now also 
provides a value, \code{NA}, for the parameter (third y) that is unknown.
We also provide initial guesses for the x- and y-values (\code{xguess, yguess}).
\footnote{This problem is not correctly solved if the initial guess for 
 the y-values is 0; yet any value different from 0 works}
<<>>=
Sol <- bvptwp (yini= c(y=1,dy=0,lam=NA), yend = c(NA,0,NA),
        x=seq(0,pi,by=0.01), func=mathieu2, xguess = c(0,1,2*pi),
        yguess = matrix(nr=3,rep(15,9)) )
@
The y-value, its derivative, and \code{lambda}, are plotted
<<label=mat2,include=FALSE>>=
plot(Sol, type = "l", lwd=2)
mtext(outer=TRUE, side=3, line=-1.5, cex=1.5, "mathieu - solved using bvptwp")
@
\setkeys{Gin}{width=0.8\textwidth}
\begin{figure}
\begin{center}
<<label=mat2,fig=TRUE,echo=FALSE>>=
<<mat2>>
@
\end{center}
\caption{Solution of the BVP ODE problem including an unknown parameter,
  and using method bvptwp - see text for R-code}
\label{fig:mat}
\end{figure}


\clearpage
\section{Specifying the analytic jacobians}
By default, the Jacobians of the derivative function and of the boundary
conditions, are estimated numerically. It is however possible - and faster -
to provide the analytical solution of the jacobian.

As an example, the \code{elastica} problem is implemented
(\url{http://www.ma.ic.ac.uk/~jcash/BVP_software}).

First implementation uses the default specification:
<<>>=
Elastica <- function (x, y, pars) {

  list( c(cos(y[3]),
          sin(y[3]),
          y[4],
          y[5]*cos(y[3]),
          0))
}

Sol <- bvptwp(func=Elastica,
              yini = c(x=0, y=0, p=NA,   k=0, F=NA),
              yend = c(x=NA,y=0, p=-pi/2,k=NA,F=NA),
              x = seq(0,0.5,len=16),
              guess=c(0,0) )
@
<<label=elastica,include=FALSE>>=
plot(Sol)
@
\setkeys{Gin}{width=0.6\textwidth}
\begin{figure}
\begin{center}
<<label=elastica,fig=TRUE,echo=FALSE>>=
<<elastica>>
@
\end{center}
\caption{Solution of the elastica problem - see text for R-code}
\label{fig:elastica}
\end{figure}

Now several extra functions are defined, specifying
\begin{enumerate}
 \item the analytic Jacobian for the derivative function (\code{jacfunc})
 \item the boundary function (\code{bound}). Here \code{i} is the boundary
   condition "number". The conditions at the left are enumerated first,
   then the ones at the right.  For instance, i = 1 specifies the boundary
   for y(0) = 0, or BC(1) = y[1]-0; the fifth boundary condition is y[3] = -pi/2 or
   BC = y[3] + pi/2
 \item the analytic Jacobian for the boundary function (\code{jacbound})
\end{enumerate}

This is done in the \R-code below:
<<>>=

Jac <- matrix(nr=5,nc=5,0)
Jac[3,4]=1.0
Jac[4,4]=1.0

jacfunc <- function (x, y, pars) {
      Jac[1,3]=-sin(y[3])
      Jac[2,3]=cos(y[3])
      Jac[4,3]=-y[5]*sin(y[3])
      Jac[4,5]=Jac[2,3]
      Jac
}

bound <- function (i, y, pars)  {
    if (i <=2) return(y[i])
    else if (i == 3) return(y[4])
    else if (i == 4) return(y[2])
    else if (i == 5) return(y[3]+pi/2)
}

jacbound <- function(i, y, pars)  {
    JJ <- rep(0,5)
         if (i <=2) JJ[i] =1.0
    else if (i ==3) JJ[4] =1.0
    else if (i ==4) JJ[2] =1.0
    else if (i ==5) JJ[3] =1.0
    JJ
}
@
If this input is used, the number of left boundary conditions \code{leftbc}
needs to be specified.
<<>>=
Sol4 <- bvptwp(leftbc = 3,
              func=Elastica, jacfunc = jacfunc,
              bound = bound, jacbound = jacbound,
              x = seq(0,0.5,len=16),
              guess=c(0,0) )
@

Solving the model this way is about 3 times faster than the default.

\clearpage
\section{implementing a BVP problem in compiled code}
Even more computing time is saved by specifying the problem in lower-level
languages such as \proglang{FORTRAN} or \proglang{C}, or \proglang{C++},
which are compiled into a dynamically linked library (DLL) and loaded
into \R.

This is similar as the differential equations from package \ds \citep{deSolve}.

Its vignette ("compiledCode") can be consulted for more information.
(\url{http://cran.r-project.org/package=deSolve/})

In order to create compiled models (.DLL = dynamic link libraries on Windows
or .so = shared objects on other systems) you must have a recent version of
the GNU compiler suite installed, which is quite standard for Linux.

Windows users find all the required tools on
\url{http://www.murdoch-sutherland.com/Rtools/}.
Getting DLLs produced by other compilers to communicate with R is much more
complicated and therefore not recommended. More details can be found on
\url{http://cran.r-project.org/doc/manuals/R-admin.html}.

The call to the derivative, boundary and Jacobian functions is more complex
for compiled code compared to \R-code, because it has to comply with the
interface needed by the integrator source codes.

\subsection{The elastica problem in FORTRAN}
Below is an implementation of the elastica model in \proglang{FORTRAN}:
(slightly modified from \url{http://www.ma.ic.ac.uk/~jcash/BVP_software}):

\begin{verbatim}
c  The differential system:
      SUBROUTINE fsub(NCOMP,X,Z,F,RPAR,IPAR)
      IMPLICIT NONE
      INTEGER NCOMP, IPAR  , I
      DOUBLE PRECISION F, Z, RPAR, X
      DIMENSION Z(*),F(*)
      DIMENSION RPAR(*), IPAR(*)

      F(1)=cos(Z(3))
      F(2)=sin(Z(3))
      F(3)=Z(4)
      F(4)=Z(5)*cos(Z(3))
      F(5)=0

      RETURN
      END

c The analytic Jacobian for the F-function:
      SUBROUTINE dfsub(NCOMP,X,Z,DF,RPAR,IPAR)
      IMPLICIT NONE
      INTEGER NCOMP, IPAR, I, J
      DOUBLE PRECISION X, Z, DF, RPAR
      DIMENSION Z(*),DF(NCOMP,*)
      DIMENSION RPAR(*), IPAR(*)
      CHARACTER (len=50) str

      DO I=1,5
         DO J=1,5
            DF(I,J)=0.D0
         END DO
      END DO

      DF(1,3)=-sin(Z(3))
      DF(2,3)=cos(Z(3))
      DF(3,4)=1.0D0
      DF(4,3)=-Z(5)*sin(Z(3))
      DF(4,4)=1.0D0
      DF(4,5)=cos(Z(3))

      RETURN
      END

c The boundary conditions:
      SUBROUTINE gsub(I,NCOMP,Z,G,RPAR,IPAR)
      IMPLICIT NONE
      INTEGER I, NCOMP, IPAR
      DOUBLE PRECISION Z, RPAR, G
      DIMENSION Z(*)
      DIMENSION RPAR(*), IPAR(*)


      IF (I.EQ.1) G=Z(1)
      IF (I.EQ.2) G=Z(2)
      IF (I.EQ.3) G=Z(4)
      IF (I.EQ.4) G=Z(2)
      IF (I.EQ.5) G=Z(3)+1.5707963267948966192313216916397514D0

      RETURN
      END

c The analytic Jacobian for the boundaries:
      SUBROUTINE dgsub(I,NCOMP,Z,DG,RPAR,IPAR)
      IMPLICIT NONE
      INTEGER I, NCOMP, IPAR
      DOUBLE PRECISION Z, DG, RPAR
      DIMENSION Z(*),DG(*)
      DIMENSION RPAR(*), IPAR(*)

      DG(1)=0.D0
      DG(2)=0.D0
      DG(3)=0.D0
      DG(4)=0.D0
      DG(5)=0.D0

C     dG1/dZ1
      IF (I.EQ.1) DG(1)=1.D0
C     dG2/dZ2
      IF (I.EQ.2) DG(2)=1.D0
C     dG3/dZ4
      IF (I.EQ.3) DG(4)=1.D0
C     dG4/dZ2
      IF (I.EQ.4) DG(2)=1.D0
C     dG5/dZ3
      IF (I.EQ.5) DG(3)=1.D0

      RETURN
      END

\end{verbatim}

\subsection{The elastica problem in C}
The same model, implemented in \proglang{C} is:
\begin{verbatim}
#include <math.h>

//  The differential system:

  void fsub(int *n, double *x, double *z, double *f,
        double * RPAR, int * IPAR)  {

      f[0]=cos(z[2]);
      f[1]=sin(z[2]);
      f[2]=z[3]     ;
      f[3]=z[4]*cos(z[2]);
      f[4]=0;
  }

// The analytic Jacobian for the F-function:

  void dfsub(int * n, double *x, double *z, double * df,
      double *RPAR, int *IPAR)  {

      int j;
      for (j = 0; j< *n * *n; j++) df[j] = 0;

      df[*n *2]    = -sin(z[2]);
      df[*n *2 +1] = cos(z[2]);
      df[*n *3 +2] = 1.0;
      df[*n *2 +3] = -z[4]*sin(z[2]);
      df[*n *3 +3] = 1.0;
      df[*n *4 +3] = cos(z[2]);
  }

// The boundary conditions:

  void gsub(int *i, int *n, double *z, double *g,
      double *RPAR, int *IPAR)  {

      if (*i==1) *g=z[0];
      else if (*i==2) *g=z[1];
      else if (*i==3) *g=z[3];
      else if (*i==4) *g=z[1];
      else if (*i==5) *g=z[2]+1.5707963267948966192313216916397514;
  }

// The analytic Jacobian for the G-function:

  void dgsub(int *i, int *n, double *z, double *dg,
      double *RPAR, int *IPAR)  {

      int j;
      for (j = 0; j< *n; j++) dg[j] = 0;

      if (*i == 1) dg[0] = 1.;
      else if (*i == 2) dg[1] = 1.;
      else if (*i == 3) dg[3] = 1.;
      else if (*i == 4) dg[1] = 1.;
      else if (*i == 5) dg[2] = 1.;
  }

\end{verbatim}

\subsection{Solving the elastica problem specified in compiled code}

In what follows, it is assumed that the codes are saved in a file called
\code{elastica.f}, and \code{elasticaC.c} and that these files are in the
working directory of \R. (if not, use \code{setwd()} )

Before the functions can be executed, the \proglang{fortran} or \proglang{C}-
code has to be compiled

This can simply be done in R:

\begin{verbatim}
 system("R CMD SHLIB elastica.f")
 system("R CMD SHLIB elasticaC.c")
\end{verbatim}
or

\begin{verbatim}
system("gfortran -shared -o elastica.dll elastica.f")
system("gcc -shared -o elasticaC.dll elasticaC.c")
\end{verbatim}

This will create a file called \code{elastica.dll} and \code{elasticaC.dll}
respectively (on windows).

After loading the DLL, the model can be run, after which the dll is unloaded.
For the Fortran, this is done as follows (the C code is similar, except for
the name of the DLL):
\begin{verbatim}

dyn.load("elastica.dll")

outF <- bvptwp(ncomp=5,
               x = seq(0,0.5,len=16), leftbc = 3,
               func="fsub",jacfunc="dfsub",bound="gsub",jacbound="dgsub",
               dllname="elastica")

dyn.unload("elastica.dll")

\end{verbatim}
%% the elastica problem implemented in C has been made a part of the package
<<include=FALSE>>=
outF <- bvptwp(ncomp=5,
               x = seq(0,0.5,len=16), leftbc = 3,
               func="fsub",jacfunc="dfsub",bound="gsub",jacbound="dgsub",
               dllname="bvpSolve")
@

Note that the number of components (equations) needs to be explicitly
inputted (\code{ncomp}).

This model is about 8-10 times faster than the pure \R implementation from
previous section.

The solver recognizes that the model is specified as a DLL due to
the fact that arguments \code{func}, \code{jacfunc}, \code{bound} and
\code{jacbound} are not regular \R-functions but character strings.

Thus, the solver will check whether these functions are loaded in the DLL
with name "elastica.dll".  Note that the name of the DLL should be
specified without extension.

This DLL should contain all the compiled function or subroutine definitions
needed.

Also, if \code{func} is specified in compiled code, then \code{jacfunc},
\code{bound} and \code{jacbound} should also be specified in a compiled
language. It is not allowed to mix R-functions and compiled functions.

\clearpage
\section{Passing parameters and external data to compiled code}

When using compiled code, it is possible to
\begin{itemize}
 \item pass \emph{parameters} from \R to the compiled functions
 \item pass \emph{forcing functions} from \R to compiled functions.
   These are then updated to the correct value of the independent variable
   (\code{x}) at each step.
\end{itemize}

The implementation of this is similar as in package \pkg{deSolve}. How to do
it has been extensively explained in deSolve's vignette, which can be
consulted for details.

See \url{http://cran.r-project.org/package=deSolve}.

Here we implement a simple linear boundary value problem, which is
a standard test problem for BVP code (\ref{scott}). The model has a
boundary layer at x=0.

The differential equation depends on a parameter \code{a} and \code{p}:
\[
  y'' + \frac{-a p y}{(p+x^2)^2}=0
\]
and is solved on [-0.1, +0.1] with boundary conditions:
\begin{eqnarray*}
y(-0.1) = -0.1 \sqrt{p+0.01} \\
y(+0.1) = 0.1 \sqrt{p+0.01} \\
\end{eqnarray*}
where \code{a} = 3 and \code{p} is taken small.

This differential equation is written as a system of two first-order ODEs.

The implementation in pure \R is given first:
<<>>=
fun <- function(t,y,pars)
  list(c( y[2],
        - a*p*y[1]/(p+t*t)^2
        ))
@
with parameter values:
<<>>=
p    <- 1e-5
a    <- 3
@
It is solved using \code{bvptwp}; note that the initial condition (\code{yini})
gives names to the variables; these names are used by the solver to label
the output:
<<>>=
sol  <- bvptwp(yini = c(y=-0.1/sqrt(p+0.01), dy=NA),
               yend = c(   0.1/sqrt(p+0.01),    NA),
               x = seq(-0.1, 0.1, by=0.001),
               func = fun, guess = 1)
@
<<label=linear,include=FALSE>>=
plot(sol,type="l")
@
\setkeys{Gin}{width=0.8\textwidth}
\begin{figure}
\begin{center}
<<label=linear,fig=TRUE,echo=FALSE, width=13, height=6>>=
<<linear>>
@
\end{center}
\caption{Solution of the linear boundary problem - see text for R-code}
\label{fig:linear}
\end{figure}

Next the FORTRAN implementation is given, which requires writing the
bounary and jacobian functions (\code{bound}, \code{jacfunc} and \code{jacbound})

The two parameters are initialised in a function called \code{initbnd}; its
name is passed to function \code{bvptwp} via argument \code{initfunc}.

\begin{verbatim}
c FORTRAN implementation of the boundary problem
c Initialiser for parameter common block
      SUBROUTINE initbnd(bvpparms)
      EXTERNAL bvpparms

      DOUBLE PRECISION parms(2)
      COMMON / pars / parms

       CALL bvpparms(2, parms)
      END

c derivative function
      SUBROUTINE funbnd(NCOMP,X,Y,F,RPAR,IPAR)
      IMPLICIT NONE
      INTEGER NCOMP, IPAR(*), I
      DOUBLE PRECISION F(2), Y(2), RPAR(*), X
      DOUBLE PRECISION a, p
      COMMON / pars / a, p

        F(1)= Y(2)
        F(2)= - a * p *Y(1)/(p+ x*x)**2
      END

c The analytic Jacobian for the derivative-function:
      SUBROUTINE dfbnd(NCOMP,X,Y,DF,RPAR,IPAR)
      IMPLICIT NONE
      INTEGER NCOMP, IPAR(*), I, J
      DOUBLE PRECISION X, Y(2), DF(2,2), RPAR(*)
      DOUBLE PRECISION a, p
      COMMON / pars / a, p

        DF(1,1)=0.D0
        DF(1,2)=1.D0
        DF(2,1)= - a *p /(p+x*x)**2
        DF(2,2)=0.D0
      END

c The boundary conditions:
      SUBROUTINE gbnd(I,NCOMP,Y,G,RPAR,IPAR)
      IMPLICIT NONE
      INTEGER I, NCOMP, IPAR(*)
      DOUBLE PRECISION Y(2), RPAR(*), G
      DOUBLE PRECISION a, p
      COMMON / pars / a, p

        IF (I.EQ.1) THEN
          G=Y(1) + 0.1 / sqrt(p+0.01)
        ELSE IF (I.EQ.2) THEN
          G=Y(1) - 0.1 / sqrt(p+0.01)
        ENDIF
      END

c The analytic Jacobian for the boundaries:
      SUBROUTINE dgbnd(I,NCOMP,Y,DG,RPAR,IPAR)
      IMPLICIT NONE
      INTEGER I, NCOMP, IPAR(*)
      DOUBLE PRECISION Y(2), DG(2), RPAR(*)

        DG(1)=1.D0
        DG(2)=0.D0
      END
\end{verbatim}


Before running the model, the parameters are defined:
<<>>=
parms <- c(a=3, p=1e-7)
@

and the DLL created and loaded; This model has been made part of package \bvp,
so it is available in DLL \code{bvpSolve}.

Assuming that this was not the case, and the code is in a file called
\code{"boundary_for.f"}, this is how to compile this code and load the DLL
(on windows):
\begin{verbatim}
system("R CMD SHLIB boundary_for.f")
dyn.load("boundary_for.dll")
\end{verbatim}

We execute the model several times, for different values of parameter \code{p};
we create a sequence of parameter values (\code{pseq}), over which the model
then iterates (\code{for (pp in pseq)}); the resulting \code{y}-values
($2^{nd}$) column) of each iteration are added to matrix \code{Out}.
added to

<<>>=
Out  <- NULL
x    <- seq(-0.1,0.1,by=0.001)
pseq <- 10^-seq(0,6,0.5)

for (pp in pseq) {
  parms[2] <- pp
  outFor <- bvptwp(ncomp=2,
               x = x, leftbc = 1, initfunc="initbnd", parms=parms, guess=1,
               func="funbnd",jacfunc="dfbnd",bound="gbnd",jacbound="dgbnd",
               allpoints=FALSE,dllname="bvpSolve")
  Out <- cbind(Out, outFor[,2])
}
@
It takes less than 0.06 seconds to do this.

Results are plotted, using \R-function \code{matplot}:
<<>>=
@
<<label=linf,include=FALSE>>=
matplot(x,Out,type="l")
legend("topleft", legend=log10(pseq), title="logp",
  col=1:length(pseq), lty=1:length(pseq), cex=0.6)
@
\setkeys{Gin}{width=0.6\textwidth}
\begin{figure}
\begin{center}
<<label=linf,fig=TRUE,echo=FALSE>>=
<<linf>>
@
\end{center}
\caption{Multiple solutions of the linear problem - see text for R-code}
\label{fig:linp}
\end{figure}
\clearpage

\bibliography{docs}

\end{document}

